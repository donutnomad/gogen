// Code generated by gogen. DO NOT EDIT.
package approvegen

import (
	"context"
	"errors"
	"fmt"

	"github.com/bytedance/sonic"
)

// ================ templategen ================

// ========================== Interfaces ==========================

type IPostUseCase interface {
	PostSave(ctx context.Context, cmd *SaveCmd, body Transition, result ApprovalResult) error
}

type IApprovalFormatter interface {
	FormatSave(ctx context.Context, cmd *SaveCmd, raw any) (any, error)
	FormatDelete(ctx context.Context, id uint64, raw any) (any, error)
}

// ========================== Method Arg Structs ==========================

type _UseCaseMethodSave struct {
	Cmd *SaveCmd
}

func (p *_UseCaseMethodSave) MethodName() string {
	return "approvegen_UseCase_Save"
}

type _UseCaseMethodDelete struct {
	Id uint64
}

func (p *_UseCaseMethodDelete) MethodName() string {
	return "approvegen_UseCase_Delete"
}

// ========================== Approval Methods ==========================

func (u *UseCase) CreateApproval(ctx context.Context, module, event string, arg interface {
	MethodName() string
}, detail any) error {
	// TODO: Implement approval creation logic
	return nil
}

func (u *UseCase) ApproveForSave(
	ctx context.Context,
	cmd *SaveCmd,
	formatter IApprovalFormatter,
) error {
	arg := &_UseCaseMethodSave{
		Cmd: cmd,
	}
	detail, err := (&ApprovalCaller{formatter: formatter}).Format(ctx, arg)
	if err != nil {
		return err
	}
	return u.CreateApproval(ctx, "APPROVALNODES", "SAVE", arg, detail)
}

func (u *UseCase) ApproveForDelete(
	ctx context.Context,
	id uint64,
	formatter IApprovalFormatter,
) error {
	arg := &_UseCaseMethodDelete{
		Id: id,
	}
	detail, err := (&ApprovalCaller{formatter: formatter}).Format(ctx, arg)
	if err != nil {
		return err
	}
	return u.CreateApproval(ctx, "APPROVALNODES", "DELETE", arg, detail)
}

// ========================== ApprovalCaller ==========================

type ApprovalCaller struct {
	targets   []any
	formatter IApprovalFormatter
}

func NewApprovalCaller(formatter IApprovalFormatter, targets ...any) *ApprovalCaller {
	return &ApprovalCaller{targets: targets, formatter: formatter}
}

func (amc *ApprovalCaller) Call(ctx context.Context, arg any, approved bool) (any, error) {
	switch p := arg.(type) {
	case *_UseCaseMethodSave:
		type ApprovedInterface interface {
			Save(ctx context.Context, cmd *SaveCmd) error
		}
		for _, t := range amc.targets {
			if approved {
				if target, ok := t.(ApprovedInterface); ok {
					err := target.Save(ctx, p.Cmd)
					if err != nil {
						return nil, err
					}
					return nil, nil
				}
			}
		}
		if !approved {
			return nil, nil
		}
	case *_UseCaseMethodDelete:
		type ApprovedInterface interface {
			Delete(ctx context.Context, id uint64) error
		}
		for _, t := range amc.targets {
			if approved {
				if target, ok := t.(ApprovedInterface); ok {
					err := target.Delete(ctx, p.Id)
					if err != nil {
						return nil, err
					}
					return nil, nil
				}
			}
		}
		if !approved {
			return nil, nil
		}
	}
	return nil, errors.New("CodeUnknownMethod")
}

func (amc *ApprovalCaller) UnmarshalMethodArgs(method string, content string) (any, error) {
	switch method {
	case "approvegen_UseCase_Save":
		var p _UseCaseMethodSave
		if err := sonic.Unmarshal([]byte(content), &p); err != nil {
			return nil, err
		}
		return &p, nil
	case "approvegen_UseCase_Delete":
		var p _UseCaseMethodDelete
		if err := sonic.Unmarshal([]byte(content), &p); err != nil {
			return nil, err
		}
		return &p, nil
	default:
		return nil, nil
	}
}

func (amc *ApprovalCaller) Format(ctx context.Context, arg any) (any, error) {
	switch v := arg.(type) {
	case *_UseCaseMethodSave:
		return amc.formatter.FormatSave(ctx, v.Cmd, v)
	case *_UseCaseMethodDelete:
		return amc.formatter.FormatDelete(ctx, v.Id, v)
	}
	return nil, errors.Join(errors.New("CodeUnsupportedArgType"), fmt.Errorf("unsupported arg type %T", arg))
}

// ========================== Caller (Vote Completion Handler) ==========================

type Caller struct {
	useCase  IPostUseCase
	voteRepo any // vote.Repo
}

func NewCaller(useCase IPostUseCase, voteRepo any) *Caller {
	return &Caller{useCase: useCase, voteRepo: voteRepo}
}

func (c *Caller) Call(ctx context.Context, event any) error {
	// TODO: Implement vote completion handling
	// 1. Get vote job by refType and refID
	// 2. Parse method args using ApprovalCaller.UnmarshalMethodArgs
	// 3. Dispatch to appropriate Post{Method} based on method name

	/*
		method, err := (&ApprovalCaller{}).UnmarshalMethodArgs(job.Method.Method, job.Method.MethodArgs)
		if err != nil {
			return err
		}
		switch v := method.(type) {
		case *_UseCaseMethodSave:
			var bodyData VoteData[any, Transition]
			if err := json.Unmarshal(job.Body, &bodyData); err != nil {
				return err
			}
			return c.useCase.PostSave(ctx, v.Cmd, bodyData.Raw, approvalResult)
		default:
			return errors.New("unsupported method")
		}
	*/
	return nil
}
