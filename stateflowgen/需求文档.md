# 状态流转注解系统 (StateFlow Generator) 设计方案

## 1. 设计决策总结

| 决策项 | 选择 |
|--------|------|
| 注解格式 | `@StateFlow(name="xxx")` + 多个 `@Flow:` 规则 |
| 注解载体 | 独立存在，不依附于任何声明 |
| 生成范围 | 枚举 + Stage + State + 流转方法 |
| 状态模型 | Status 是 Phase 专属 |
| 通配符 | 仅 Status 通配（`*`），不含自我流转 |
| 初始状态 | 隐式推断（第一条规则的 Source） |
| 无状态处理 | Status 为空字符串 `""` |
| 审批模式 | 三种：无标记 / `!`（必须）/ `?`（可选） |
| 状态结构 | `Stage`（纯阶段）+ `State`（含 Pending） |
| 核心方法 | `TransitionTo` 返回新 State（值对象） |
| 错误处理 | DSL 语法错误时编译失败 |

---

## 2. DSL 语法规范

### 2.1 完整语法格式

```go
// @StateFlow(name="Server")
// @Flow: Source(Status) => [ Target1(Status)!, Target2? ]
```

### 2.2 符号定义

| 符号 | 含义 | 示例 |
|------|------|------|
| `!` | 必须审批 | `Deleted!` |
| `?` | 可选审批（由 withApproval 参数决定） | `Disabled?` |
| `*` | Status 通配符（匹配任意状态） | `Ready(*)` |
| `=` | 自我流转（保持原样） | `(=)!` |
| `()` | 纯状态切换（Phase 不变） | `=> [ (Disabled) ]` |
| `via` | 审批中间状态 | `Created! via Updating` |
| `else` | 审批拒绝后的状态 | `Created! via Updating else Failed` |

### 2.3 审批中间状态语法

```go
// 完整语法：Target! via Intermediate else Rejected
// - Target: 审批通过后的最终状态
// - Intermediate: 审批中的中间状态
// - Rejected: 审批拒绝后的状态（可选，默认回退原状态）

// 示例1：拒绝后回退原状态（默认）
@Flow: Ready(Enabled) => [ Created! via Updating ]
// Ready -> Updating -> Commit -> Created
//                   -> Reject -> Ready(Enabled)  // 回退原状态

// 示例2：拒绝后前往指定状态
@Flow: Ready(Enabled) => [ Created! via Updating else Failed ]
// Ready -> Updating -> Commit -> Created
//                   -> Reject -> Failed  // 前往指定状态
```

**流程图：**
```
                    +--Commit--> Created (Target)
                    |
Ready(Enabled) --> Updating (Intermediate)
                    |
                    +--Reject--> Ready(Enabled) 或 Failed (else 指定)
```

### 2.4 完整示例

```go
// =========================================================
// 服务器生命周期拓扑图
// =========================================================
//
// @StateFlow(name="Server")
// @Flow: Init           => [ Provisioning ]
// @Flow: Provisioning   => [ Ready(Enabled), Failed ]
// @Flow: Ready(Enabled) => [ (Disabled)! ]
// @Flow: Ready(Disabled)=> [ (Enabled) ]
// @Flow: Ready(*)       => [ Deleted! ]
// @Flow: Failed         => [ Deleted! ]
// @Flow: Ready(Enabled) => [ (=)? ]
```

---

## 3. 生成代码规范

### 3.1 类型设计（按需生成）

**有审批符号（`!` 或 `?`）时：**

```go
// ServerStage - 纯阶段（Phase + Status）
type ServerStage struct {
    Phase  ServerPhase  `json:"phase"`
    Status ServerStatus `json:"status"`
}

// ServerPendingTransition - 审批事务
type ServerPendingTransition struct {
    From     ServerStage `json:"from"`     // 原阶段
    To       ServerStage `json:"to"`       // 目标阶段（Commit 后）
    Fallback ServerStage `json:"fallback"` // 回退阶段（Reject 后）
}

// ServerState - 完整状态
type ServerState struct {
    Current ServerStage              `json:"current"`
    Pending *ServerPendingTransition `json:"pending,omitempty"`
}

func (s ServerState) TransitionTo(to ServerStage, withApproval bool) (ServerState, error)
func (s ServerState) Commit() (ServerState, error)   // Current = Pending.To, Pending = nil
func (s ServerState) Reject() (ServerState, error)   // Current = Pending.Fallback, Pending = nil
func (s ServerState) IsApprovalPending() bool        // return s.Pending != nil
```

**无审批符号时（简化版）：**

```go
// ServerStage - 纯阶段
type ServerStage struct {
    Phase  ServerPhase  `json:"phase"`
    Status ServerStatus `json:"status"`
}

// ServerState - 完整状态（无审批时等同于 Stage）
type ServerState struct {
    Current ServerStage `json:"current"`
}

func (s ServerState) TransitionTo(to ServerStage) (ServerState, error)  // 无需 withApproval
```

### 3.2 预定义阶段组合（编码规范）

```go
// ============= 预定义的有效阶段组合 =============
// 编码规范：使用这些预定义变量，而不是手动构造

var (
    StageInit            = ServerStage{ServerPhaseInit, ServerStatusNone}
    StageProvisioning    = ServerStage{ServerPhaseProvisioning, ServerStatusNone}
    StageReadyEnabled    = ServerStage{ServerPhaseReady, ServerStatusEnabled}
    StageReadyDisabled   = ServerStage{ServerPhaseReady, ServerStatusDisabled}
    StageFailed          = ServerStage{ServerPhaseFailed, ServerStatusNone}
    StageDeleted         = ServerStage{ServerPhaseDeleted, ServerStatusNone}
    StageUpdating        = ServerStage{ServerPhaseUpdating, ServerStatusNone}  // 中间状态
)

// 使用示例：
// state.TransitionTo(StageReadyEnabled, false)  ✓ 推荐
// state.TransitionTo(ServerStage{...}, false)   ✗ 不推荐
```

**审批流程语义：**
1. **正常状态**：`Pending = nil`
2. **发起审批**：`Current = 中间阶段`, `Pending = {From, To, Fallback}`
3. **审批通过（Commit）**：`Current = Pending.To`, `Pending = nil`
4. **审批拒绝（Reject）**：`Current = Pending.Fallback`, `Pending = nil`

### 3.3 枚举定义

```go
// ServerPhase 服务器阶段
type ServerPhase string

const (
    ServerPhaseInit         ServerPhase = "Init"
    ServerPhaseProvisioning ServerPhase = "Provisioning"
    ServerPhaseReady        ServerPhase = "Ready"
    ServerPhaseFailed       ServerPhase = "Failed"
    ServerPhaseDeleted      ServerPhase = "Deleted"
)

// ServerStatus 服务器状态（Phase 专属）
type ServerStatus string

const (
    ServerStatusNone     ServerStatus = ""         // 无状态
    ServerStatusEnabled  ServerStatus = "Enabled"
    ServerStatusDisabled ServerStatus = "Disabled"
)
```

### 3.4 核心方法

```go
// TransitionTo 尝试流转到目标阶段（值对象，返回新状态）
// withApproval: 是否走审批流程（仅对 ? 可选审批生效）
//   - ! 必须审批：忽略参数，始终进入审批（中间阶段）
//   - ? 可选审批：根据参数决定
//   - 无标记：忽略参数，直接流转
func (s ServerState) TransitionTo(to ServerStage, withApproval bool) (ServerState, error)

// Commit 审批通过，从中间阶段流转到目标阶段
// 仅当 Pending != nil 时可调用
func (s ServerState) Commit() (ServerState, error)

// Reject 审批拒绝，从中间阶段流转到回退阶段
// 仅当 Pending != nil 时可调用
func (s ServerState) Reject() (ServerState, error)

// IsApprovalPending 是否有审批进行中
func (s ServerState) IsApprovalPending() bool

// ValidTransitions 返回当前阶段的所有有效流转目标
func (s ServerState) ValidTransitions() []ServerStage

// 错误定义
var (
    ErrInvalidTransition  = errors.New("invalid transition")   // 规则不存在
    ErrApprovalInProgress = errors.New("approval in progress") // 已有审批进行中
    ErrNotInApproval      = errors.New("not in approval")      // 未在审批中，无法 Commit/Reject
)
```

**行为矩阵：**

| 规则标记 | withApproval=false | withApproval=true |
|---------|-------------------|-------------------|
| 无标记 | 直接流转 | 直接流转 |
| `?` 可选 | 直接流转 | 进入中间阶段 |
| `!` 必须 | 进入中间阶段 | 进入中间阶段 |

**使用示例：**

```go
// 场景1：普通流转（不需要审批）
newState, err := state.TransitionTo(StageProvisioning, false)
// newState.Current = StageProvisioning
// newState.Pending = nil

// 场景2：必须审批的流转（有中间阶段）
// DSL: Ready(Enabled) => [ Created! via Updating ]
newState, err := state.TransitionTo(StageCreated, false)
// newState.Current = StageUpdating（中间阶段）
// newState.Pending = {From: StageReadyEnabled, To: StageCreated, Fallback: StageReadyEnabled}

// 场景3：审批通过
finalState, err := newState.Commit()
// finalState.Current = StageCreated
// finalState.Pending = nil

// 场景4：审批拒绝
rollbackState, err := newState.Reject()
// rollbackState.Current = StageReadyEnabled（或 else 指定的阶段）
// rollbackState.Pending = nil
```

### 3.5 校验与优化规则

**1. 节点类型定义**

| 节点类型 | 定义 | 合法性 |
|---------|------|--------|
| 起始态 | 只有出边，没有入边 | ✓ 合法（如 Init） |
| 终态 | 只有入边，没有出边 | ✓ 合法（如 Deleted） |
| 中间态 | 有入边也有出边 | ✓ 合法 |
| via 中间状态 | 只在 `via` 中出现 | ✓ 合法（特殊处理） |
| 孤立节点 | 既无入边也无出边 | ✗ 错误 |

**2. 孤立节点检测**

孤立节点 = 既没有入边也没有出边的节点（排除起始态、终态、via 中间状态）：

```go
// 错误示例：
// @Flow: Init => [ Provisioning ]
// @Flow: Ready(Enabled) => [ (Disabled) ]
//
// 错误：Ready 既不是起始态也不是其他状态的目标，是孤立节点
// 注意：Provisioning 有入边（来自 Init），需要出边才合法
```

**3. 单节点声明（无流转）**

当只存在一个节点时，不需要流转，只生成枚举和 Stage 类型：

```go
// 只有一个节点，无流转：
// @StateFlow(name="Server")
// @Flow: Init

// 只生成枚举和 Stage，不生成 State 和方法
```

**4. 无 Status 优化**

当整个流程定义都没有涉及 Status 时，Stage 直接用 Phase 的别名：

```go
// 无 Status 的流程 → 生成别名：
type ServerStage = ServerPhase

// 有 Status 的流程 → 生成结构体：
type ServerStage struct {
    Phase  ServerPhase
    Status ServerStatus
}
```

**5. 通配符展开规则**

`*` 展开时不包含自我流转：

```go
// @Flow: Ready(*) => [ (Disabled) ]
// 展开为：
// - Ready(Enabled) => Ready(Disabled)  ✓
// - Ready(Disabled) => Ready(Disabled) ✗ 不包含（自我流转）
```

**6. 同一源状态多条规则合并**

同一源状态的多条规则会合并为一个目标列表：

```go
// @Flow: Ready(Enabled) => [ (Disabled)! ]
// @Flow: Ready(*) => [ Deleted! ]
// @Flow: Ready(Enabled) => [ (=)? ]

// Ready(Enabled) 的有效目标合并为：
// - Ready(Disabled)!  (来自第一条)
// - Deleted!          (来自第二条展开)
// - Ready(Enabled)?   (来自第三条，自我流转)

// TransitionTo 时根据传入的 to 参数匹配对应规则
```

**7. 自我流转 + via 的语义**

自我流转 `(=)` 表示阶段不变，可以配合 `via` 使用：

```go
// @Flow: Ready(Enabled) => [ (=)! via Updating ]
// 含义：Ready(Enabled) 需要审批才能"保持原状"
// 流程：Ready(Enabled) -> Updating -> Commit -> Ready(Enabled)
//                                  -> Reject -> Fallback
```

---

## 4. 实施步骤

### 4.1 第一步：扩展注解解析器

修改 `plugin/annotation.go`，支持独立注解和 `@Flow:` 格式：

```go
// 支持两种注解格式：
// 1. @StateFlow(name="Server") - 传统格式
// 2. @Flow: Init => [ Provisioning ] - DSL 格式

var flowAnnotationRegex = regexp.MustCompile(`@Flow:\s*(.+)`)
var stateFlowAnnotationRegex = regexp.MustCompile(`@StateFlow\(([^)]*)\)`)
```

**注解扫描逻辑调整：**
- 支持"独立注解"（不依附于任何声明）
- `@StateFlow` 作为配置注解
- `@Flow` 作为规则注解

### 4.2 第二步：创建 DSL 解析器

新建 `stateflowgen/parser.go`：

```go
// StateFlowConfig 配置注解解析结果
type StateFlowConfig struct {
    Name   string // 类型前缀，如 "Server"
    Output string // 可选：输出文件路径
}

// FlowRule 单条流转规则
type FlowRule struct {
    Source  StateRef
    Targets []TargetRef
}

// StateRef 源状态引用
type StateRef struct {
    Phase    string // Phase 名称
    Status   string // Status 名称，可为空
    Wildcard bool   // 是否为 * 通配符
}

// TargetRef 目标状态引用（包含审批信息）
type TargetRef struct {
    Phase            string // Phase 名称，可为空（纯状态切换时继承源 Phase）
    Status           string // Status 名称，可为空
    Self             bool   // 是否为 = 自我流转
    ApprovalRequired bool   // ! 标记
    ApprovalOptional bool   // ? 标记
    Via              string // via 中间状态（Phase 名称）
    Else             string // else 拒绝后状态（Phase 名称），为空则回退原状态
}

func ParseStateFlowConfig(text string) (*StateFlowConfig, error)
func ParseFlowRule(line string) (*FlowRule, error)
```

### 4.3 第三步：状态模型构建

新建 `stateflowgen/model.go`：

```go
// StateModel 完整状态模型
type StateModel struct {
    Name         string              // 类型前缀
    Phases       []string            // 所有 Phase（保持定义顺序）
    PhaseStatus  map[string][]string // Phase -> Status 列表
    HasStatus    bool                // 是否有任何 Status 定义
    HasApproval  bool                // 是否有任何审批标记
    Transitions  []Transition        // 展开后的所有流转
    InitStage    Stage               // 初始阶段
    ViaPhases    []string            // via 中间状态列表
}

// Stage 阶段（Phase + Status）
type Stage struct {
    Phase  string
    Status string
}

// Transition 展开后的单条流转
type Transition struct {
    From             Stage  // 源阶段
    To               Stage  // 目标阶段
    ApprovalRequired bool   // ! 标记
    ApprovalOptional bool   // ? 标记
    Via              Stage  // via 中间阶段（审批时）
    Fallback         Stage  // else 拒绝后阶段（为空则等于 From）
}

func BuildModel(config *StateFlowConfig, rules []FlowRule) (*StateModel, error)
```

### 4.4 第四步：代码生成器

新建 `stateflowgen/generator.go`：

```go
type StateFlowGenerator struct {
    plugin.BaseGenerator
}

func NewStateFlowGenerator() *StateFlowGenerator {
    return &StateFlowGenerator{
        BaseGenerator: *plugin.NewBaseGenerator(
            "stateflow",
            []string{"StateFlow", "Flow"},
            []plugin.TargetKind{plugin.TargetIndependent}, // 新增：独立注解类型
        ),
    }
}

func (g *StateFlowGenerator) Generate(ctx *plugin.GenerateContext) (*plugin.GenerateResult, error)
```

### 4.5 第五步：注册生成器

在 `cmd/main.go` 中注册：

```go
func init() {
    plugin.MustRegister(stateflowgen.NewStateFlowGenerator())
}
```

---

## 5. 文件结构

```
stateflowgen/
├── parser.go       # DSL 解析器
├── parser_test.go  # 解析器测试
├── model.go        # 状态模型构建
├── model_test.go   # 模型测试
├── generator.go    # 代码生成器
├── codegen.go      # 代码生成（使用 gg 库）
└── codegen_test.go # 代码生成测试
```

---

## 6. 注解解析器扩展

### 6.1 新增 TargetKind

```go
const (
    TargetStruct      TargetKind = iota + 1
    TargetInterface
    TargetFunc
    TargetMethod
    TargetVar
    TargetConst
    TargetIndependent  // 新增：独立注解（不依附于任何声明）
)
```

### 6.2 独立注解扫描

```go
// ScanIndependentAnnotations 扫描独立注解
// 独立注解：在文件顶部或任意位置，不依附于声明
func ScanIndependentAnnotations(file *ast.File) []*Annotation
```

---

## 7. 验证计划

### 7.1 单元测试

1. **DSL 解析测试**
    - 基本流转：`Init => [ Provisioning ]`
    - 带状态：`Ready(Enabled) => [ (Disabled) ]`
    - 通配符：`Ready(*) => [ Deleted ]`（不含自我流转）
    - 审批标记：`!` 和 `?`
    - 自我流转：`(=)!`
    - via 中间状态：`Created! via Updating`
    - else 拒绝状态：`Created! via Updating else Failed`
    - 语法错误处理

2. **状态模型测试**
    - Phase/Status 提取
    - 通配符展开（排除自我流转）
    - 初始状态推断
    - 孤立节点检测
    - 起始态/终态识别
    - 同一源状态多规则合并

3. **流转方法测试**
    - TransitionTo 正确性
    - Commit/Reject 正确性
    - ValidTransitions 完整性
    - 审批进行中阻止新流转

### 7.2 集成测试

创建 `testdata/server_stateflow.go`：

```go
package testdata

// @StateFlow(name="Server")
// @Flow: Init           => [ Provisioning ]
// @Flow: Provisioning   => [ Ready(Enabled), Failed ]
// @Flow: Ready(Enabled) => [ (Disabled)! ]
// @Flow: Ready(Disabled)=> [ (Enabled) ]
// @Flow: Ready(*)       => [ Deleted! ]
// @Flow: Failed         => [ Deleted! ]
```

运行测试：
```bash
./gotoolkit gen ./testdata/...
go build ./testdata/...  # 验证编译通过
go test ./testdata/...   # 运行生成代码的测试
```

---

## 8. 生成代码示例（完整）

```go
// Code generated by stateflow generator. DO NOT EDIT.

package server

import "errors"

// ============= 枚举定义 =============

type ServerPhase string

const (
    ServerPhaseInit         ServerPhase = "Init"
    ServerPhaseProvisioning ServerPhase = "Provisioning"
    ServerPhaseReady        ServerPhase = "Ready"
    ServerPhaseUpdating     ServerPhase = "Updating"  // via 中间状态
    ServerPhaseFailed       ServerPhase = "Failed"
    ServerPhaseDeleted      ServerPhase = "Deleted"
)

type ServerStatus string

const (
    ServerStatusNone     ServerStatus = ""
    ServerStatusEnabled  ServerStatus = "Enabled"
    ServerStatusDisabled ServerStatus = "Disabled"
)

// ============= 阶段结构 =============

type ServerStage struct {
    Phase  ServerPhase  `json:"phase"`
    Status ServerStatus `json:"status"`
}

// ============= 预定义阶段 =============

var (
    StageInit            = ServerStage{ServerPhaseInit, ServerStatusNone}
    StageProvisioning    = ServerStage{ServerPhaseProvisioning, ServerStatusNone}
    StageReadyEnabled    = ServerStage{ServerPhaseReady, ServerStatusEnabled}
    StageReadyDisabled   = ServerStage{ServerPhaseReady, ServerStatusDisabled}
    StageUpdating        = ServerStage{ServerPhaseUpdating, ServerStatusNone}
    StageFailed          = ServerStage{ServerPhaseFailed, ServerStatusNone}
    StageDeleted         = ServerStage{ServerPhaseDeleted, ServerStatusNone}
)

// ============= 状态结构 =============

type ServerPendingTransition struct {
    From     ServerStage `json:"from"`
    To       ServerStage `json:"to"`
    Fallback ServerStage `json:"fallback"`
}

type ServerState struct {
    Current ServerStage              `json:"current"`
    Pending *ServerPendingTransition `json:"pending,omitempty"`
}

// ============= 错误定义 =============

var (
    ErrInvalidTransition  = errors.New("invalid transition")
    ErrApprovalInProgress = errors.New("approval in progress")
    ErrNotInApproval      = errors.New("not in approval")
)

// ============= 核心方法 =============

func (s ServerState) TransitionTo(to ServerStage, withApproval bool) (ServerState, error) {
    if s.Pending != nil {
        return s, ErrApprovalInProgress
    }

    // 查找匹配的流转规则
    rule, ok := findTransitionRule(s.Current, to)
    if !ok {
        return s, ErrInvalidTransition
    }

    // 判断是否需要审批
    needsApproval := rule.ApprovalRequired || (rule.ApprovalOptional && withApproval)

    if needsApproval && rule.Via.Phase != "" {
        // 进入中间阶段，设置 Pending
        return ServerState{
            Current: rule.Via,
            Pending: &ServerPendingTransition{
                From:     s.Current,
                To:       to,
                Fallback: rule.Fallback,
            },
        }, nil
    }

    // 直接流转
    return ServerState{Current: to}, nil
}

func (s ServerState) Commit() (ServerState, error) {
    if s.Pending == nil {
        return s, ErrNotInApproval
    }
    return ServerState{Current: s.Pending.To}, nil
}

func (s ServerState) Reject() (ServerState, error) {
    if s.Pending == nil {
        return s, ErrNotInApproval
    }
    return ServerState{Current: s.Pending.Fallback}, nil
}

func (s ServerState) IsApprovalPending() bool {
    return s.Pending != nil
}

func (s ServerState) ValidTransitions() []ServerStage {
    // 根据 s.Current 返回所有有效的目标阶段
    // ...
}
```

---

## 9. 后续扩展（可选）

以下功能可在基础版本完成后考虑添加：

1. **事件驱动模式**：`@Event: Provision => Init -> Provisioning`
2. **流转钩子**：`OnEnter`, `OnExit` 回调
3. **状态持久化**：自动生成数据库迁移
4. **可视化**：生成状态机图（Mermaid/Graphviz）

