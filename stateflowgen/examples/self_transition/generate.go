// Code generated by gogen. DO NOT EDIT.
package self_transition

import (
	"errors"

	"gorm.io/datatypes"
)

// ================ stateflow ================

/* Flowchart:
                                                                           â”Œâ”€â”€ <COMMIT> â”€â”€â–¶ Connected ğŸ”
                                                                           â”‚
                                                 â”Œâ”€â”€â–¶ Reconnecting (via) â”€â”€â”¤
                                                 â”‚                         â”‚
                                                 â”‚                         â””â”€â”€ <REJECT> â”€â”€â–¶ Connected ğŸ”
                             â”Œâ”€â”€â–¶ <?APPROVAL?> â”€â”€â”¤
                             â”‚                   â”‚
                             â”‚                   â”‚
                             â”‚                   â””â”€â”€â–¶ Connected ğŸ”
Disconnected â”€â”€â–¶ Connected â”€â”€â”¤
                             â”‚
                             â”‚
                             â”‚
                             â””â”€â”€â–¶ Disconnected ğŸ”
*/

// ConnectionPhase é˜¶æ®µæšä¸¾
type ConnectionPhase string

const (
	ConnectionPhaseDisconnected ConnectionPhase = "Disconnected"
	ConnectionPhaseConnected    ConnectionPhase = "Connected"
	ConnectionPhaseReconnecting ConnectionPhase = "Reconnecting"
)

var ConnectionPhaseEnums = struct {
	Disconnected ConnectionPhase
	Connected    ConnectionPhase
	Reconnecting ConnectionPhase
}{
	Disconnected: ConnectionPhaseDisconnected,
	Connected:    ConnectionPhaseConnected,
	Reconnecting: ConnectionPhaseReconnecting,
}

// ConnectionStage é˜¶æ®µï¼ˆPhase + Statusï¼‰
type ConnectionStage = ConnectionPhase

// é¢„å®šä¹‰é˜¶æ®µ
var (
	StageConnectionDisconnected = ConnectionPhaseDisconnected
	StageConnectionConnected    = ConnectionPhaseConnected
	StageConnectionReconnecting = ConnectionPhaseReconnecting
)

// ConnectionPendingTransition å®¡æ‰¹äº‹åŠ¡
type ConnectionPendingTransition struct {
	From     ConnectionStage `json:"from"`
	To       ConnectionStage `json:"to"`
	Fallback ConnectionStage `json:"fallback"`
}

// ConnectionState å®Œæ•´çŠ¶æ€
type ConnectionState struct {
	Current ConnectionStage              `json:"current"`
	Pending *ConnectionPendingTransition `json:"pending,omitempty"`
}

// ConnectionStateColumns æ•°æ®åº“å­˜å‚¨ç»“æ„
type ConnectionStateColumns struct {
	Phase   ConnectionPhase                                  `gorm:"column:phase" json:"phase"`
	Pending datatypes.JSONType[*ConnectionPendingTransition] `gorm:"column:pending" json:"pending"`
}

func (s ConnectionState) ToColumns() ConnectionStateColumns {
	return ConnectionStateColumns{
		Phase:   s.Current,
		Pending: datatypes.NewJSONType(s.Pending),
	}
}

func (c ConnectionStateColumns) ToState() ConnectionState {
	return ConnectionState{
		Current: c.Phase,
		Pending: c.Pending.Data(),
	}
}

// é”™è¯¯å®šä¹‰
var (
	ErrConnectionInvalidTransition  = errors.New("invalid transition")
	ErrConnectionApprovalInProgress = errors.New("approval in progress")
	ErrConnectionNotInApproval      = errors.New("not in approval")
)

func (s ConnectionState) TransitionTo(to ConnectionStage, withApproval bool) (ConnectionState, error) {
	switch s.Current {
	case StageConnectionDisconnected:
		switch to {
		case StageConnectionConnected:
			return ConnectionState{Current: to}, nil
		}
	case StageConnectionConnected:
		switch to {
		case StageConnectionConnected:
			if withApproval {
				if s.Pending != nil {
					return s, ErrConnectionApprovalInProgress
				}
				return ConnectionState{Current: StageConnectionReconnecting, Pending: &ConnectionPendingTransition{From: s.Current, To: to, Fallback: StageConnectionConnected}}, nil
			}
			return ConnectionState{Current: to}, nil
		case StageConnectionDisconnected:
			return ConnectionState{Current: to}, nil
		}
	}
	return s, ErrConnectionInvalidTransition
}

func (s ConnectionState) Commit() (ConnectionState, error) {
	if s.Pending == nil {
		return s, ErrConnectionNotInApproval
	}
	return ConnectionState{Current: s.Pending.To}, nil
}

func (s ConnectionState) Reject() (ConnectionState, error) {
	if s.Pending == nil {
		return s, ErrConnectionNotInApproval
	}
	return ConnectionState{Current: s.Pending.Fallback}, nil
}

func (s ConnectionState) IsApprovalPending() bool {
	return s.Pending != nil
}

func (s ConnectionState) ValidTransitions() []ConnectionStage {
	switch s.Current {
	case StageConnectionDisconnected:
		return []ConnectionStage{StageConnectionConnected}
	case StageConnectionConnected:
		return []ConnectionStage{StageConnectionConnected, StageConnectionDisconnected}
	}
	return nil
}

func (s ConnectionState) Next() []ConnectionState {
	if s.Pending != nil {
		return nil
	}
	var result []ConnectionState
	for _, stage := range s.ValidTransitions() {
		result = append(result, ConnectionState{Current: stage})
	}
	return result
}
