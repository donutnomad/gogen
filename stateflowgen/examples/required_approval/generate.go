// Code generated by gogen. DO NOT EDIT.
package required_approval

import (
	"errors"

	"gorm.io/datatypes"
)

// ================ stateflow ================

// æµç¨‹å›¾ï¼š
// ```
//                             â”Œâ”€â”€ <COMMIT> â”€â”€â–¶ Published â”€â”€â–¶ Archived
//                             â”‚
// Draft â”€â”€â–¶ Reviewing (via) â”€â”€â”¤
//                             â”‚
//                             â””â”€â”€ <REJECT> â”€â”€â–¶ Draft ğŸ”
// ```

// DocumentPhase é˜¶æ®µæšä¸¾
type DocumentPhase string

const (
	DocumentPhaseDraft     DocumentPhase = "Draft"
	DocumentPhasePublished DocumentPhase = "Published"
	DocumentPhaseReviewing DocumentPhase = "Reviewing"
	DocumentPhaseArchived  DocumentPhase = "Archived"
)

var DocumentPhaseEnums = struct {
	Draft     DocumentPhase
	Published DocumentPhase
	Reviewing DocumentPhase
	Archived  DocumentPhase
}{
	Draft:     DocumentPhaseDraft,
	Published: DocumentPhasePublished,
	Reviewing: DocumentPhaseReviewing,
	Archived:  DocumentPhaseArchived,
}

// DocumentStage é˜¶æ®µï¼ˆPhase + Statusï¼‰
type DocumentStage = DocumentPhase

// é¢„å®šä¹‰é˜¶æ®µ
var (
	StageDocumentDraft     = DocumentPhaseDraft
	StageDocumentPublished = DocumentPhasePublished
	StageDocumentReviewing = DocumentPhaseReviewing
	StageDocumentArchived  = DocumentPhaseArchived
)

// DocumentPendingTransition å®¡æ‰¹äº‹åŠ¡
type DocumentPendingTransition struct {
	From     DocumentStage `json:"from"`
	To       DocumentStage `json:"to"`
	Fallback DocumentStage `json:"fallback"`
}

// DocumentState å®Œæ•´çŠ¶æ€
type DocumentState struct {
	Current DocumentStage              `json:"current"`
	Pending *DocumentPendingTransition `json:"pending,omitempty"`
}

// DocumentStateColumns æ•°æ®åº“å­˜å‚¨ç»“æ„
type DocumentStateColumns struct {
	Phase   DocumentPhase                                  `gorm:"column:phase" json:"phase"`
	Pending datatypes.JSONType[*DocumentPendingTransition] `gorm:"column:pending" json:"pending"`
}

func (s DocumentState) ToColumns() DocumentStateColumns {
	return DocumentStateColumns{
		Phase:   s.Current,
		Pending: datatypes.NewJSONType(s.Pending),
	}
}

func (c DocumentStateColumns) ToState() DocumentState {
	return DocumentState{
		Current: c.Phase,
		Pending: c.Pending.Data(),
	}
}

// é”™è¯¯å®šä¹‰
var (
	ErrDocumentInvalidTransition  = errors.New("invalid transition")
	ErrDocumentApprovalInProgress = errors.New("approval in progress")
	ErrDocumentNotInApproval      = errors.New("not in approval")
)

func (s DocumentState) TransitionTo(to DocumentStage) (DocumentState, error) {
	switch s.Current {
	case StageDocumentDraft:
		switch to {
		case StageDocumentPublished:
			if s.Pending != nil {
				return s, ErrDocumentApprovalInProgress
			}
			return DocumentState{Current: StageDocumentReviewing, Pending: &DocumentPendingTransition{From: s.Current, To: to, Fallback: StageDocumentDraft}}, nil
		}
	case StageDocumentPublished:
		switch to {
		case StageDocumentArchived:
			return DocumentState{Current: to}, nil
		}
	}
	return s, ErrDocumentInvalidTransition
}

func (s DocumentState) Commit() (DocumentState, error) {
	if s.Pending == nil {
		return s, ErrDocumentNotInApproval
	}
	return DocumentState{Current: s.Pending.To}, nil
}

func (s DocumentState) Reject() (DocumentState, error) {
	if s.Pending == nil {
		return s, ErrDocumentNotInApproval
	}
	return DocumentState{Current: s.Pending.Fallback}, nil
}

func (s DocumentState) IsApprovalPending() bool {
	return s.Pending != nil
}

func (s DocumentState) ValidTransitions() []DocumentStage {
	switch s.Current {
	case StageDocumentDraft:
		return []DocumentStage{StageDocumentPublished}
	case StageDocumentPublished:
		return []DocumentStage{StageDocumentArchived}
	}
	return nil
}

func (s DocumentState) Next() []DocumentState {
	if s.Pending != nil {
		return nil
	}
	var result []DocumentState
	for _, stage := range s.ValidTransitions() {
		result = append(result, DocumentState{Current: stage})
	}
	return result
}
