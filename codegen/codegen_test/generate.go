// Code generated by gogen. DO NOT EDIT.
package codegen_test

import (
	"errors"
	"reflect"
	"unsafe"

	"google.golang.org/grpc/codes"
)

// ================ codegen ================

// GetHttpCode returns the HTTP status code for the given value.
// The bool return indicates whether the value was found, not whether http is defined.
// Returns 0 if the value is not registered.
func GetHttpCode[T comparable](v T) (int, bool) {
	_, httpCode, _, _, ok := _codegen_getInfo(v)
	return httpCode, ok
}

// GetGrpcCode returns the gRPC status code for the given value.
// The bool return indicates whether the value was found, not whether grpc is defined.
// Returns codes.Unknown if the value is not registered.
func GetGrpcCode[T comparable](v T) (codes.Code, bool) {
	_, _, grpcCode, _, ok := _codegen_getInfo(v)
	return grpcCode, ok
}

// GetCode returns the business error code for the given value.
// The bool return indicates whether the value was found.
// Returns 0 if the value is not registered.
func GetCode[T comparable](v T) (int, bool) {
	code, _, _, _, ok := _codegen_getInfo(v)
	return code, ok
}

// GetName returns the variable name for the given value.
// The bool return indicates whether the value was found.
// Returns empty string if the value is not registered.
func GetName[T comparable](v T) (string, bool) {
	_, _, _, name, ok := _codegen_getInfo(v)
	return name, ok
}

// AllCodedValues returns all registered code values.
// Each element in the slice is the original value that was annotated with @Code.
func AllCodedValues() []any {
	return []any{
		ErrUserNotFound,
		ErrDatabaseError,
		ErrInvalidInput,
		CodeInvalidInput,
		CodeNotFound,
		CodeStrUnauthorized,
		CodeStrForbidden,
	}
}

func _codegen_getInfo[T comparable](v T) (code int, httpCode int, grpcCode codes.Code, name string, ok bool) {
	val := any(v)
	if _codegen_equal(val, ErrUserNotFound) {
		return 11001, 404, codes.NotFound, "ErrUserNotFound", true
	}
	if _codegen_equal(val, ErrDatabaseError) {
		return 11002, 500, codes.Internal, "ErrDatabaseError", true
	}
	if _codegen_equal(val, ErrInvalidInput) {
		return 11003, 400, codes.InvalidArgument, "ErrInvalidInput", true
	}
	if _codegen_equal(val, CodeInvalidInput) {
		return 20001, 400, codes.InvalidArgument, "CodeInvalidInput", true
	}
	if _codegen_equal(val, CodeNotFound) {
		return 20002, 404, codes.NotFound, "CodeNotFound", true
	}
	if _codegen_equal(val, CodeStrUnauthorized) {
		return 30001, 401, codes.Unauthenticated, "CodeStrUnauthorized", true
	}
	if _codegen_equal(val, CodeStrForbidden) {
		return 30002, 403, codes.PermissionDenied, "CodeStrForbidden", true
	}
	return 0, 0, codes.Unknown, "", false
}

func _codegen_asInt64(v any) (i int64, u uint64, signed bool, ok bool) {
	switch x := v.(type) {
	case int:
		return int64(x), 0, true, true
	case int8:
		return int64(x), 0, true, true
	case int16:
		return int64(x), 0, true, true
	case int32:
		return int64(x), 0, true, true
	case int64:
		return x, 0, true, true
	case uint:
		return 0, uint64(x), false, true
	case uint8:
		return 0, uint64(x), false, true
	case uint16:
		return 0, uint64(x), false, true
	case uint32:
		return 0, uint64(x), false, true
	case uint64:
		return 0, x, false, true
	}
	return 0, 0, false, false
}

func _codegen_equalInt(a, b any) bool {
	ai, au, as, aok := _codegen_asInt64(a)
	bi, bu, bs, bok := _codegen_asInt64(b)
	if !aok || !bok {
		return false
	}
	if as && bs {
		return ai == bi
	}
	if !as && !bs {
		return au == bu
	}
	if as {
		return ai >= 0 && uint64(ai) == bu
	}
	return bi >= 0 && au == uint64(bi)
}

func _codegen_equal(a, b any) bool {
	if a == nil || b == nil {
		return a == b
	}
	if ea, ok := a.(error); ok {
		eb, ok := b.(error)
		return ok && errors.Is(ea, eb)
	}
	if sa, ok := a.(string); ok {
		sb, ok := b.(string)
		return ok && sa == sb
	}
	if _codegen_equalInt(a, b) {
		return false
	}
	va := reflect.ValueOf(a)
	vb := reflect.ValueOf(b)
	if va.Type() != vb.Type() {
		return false
	}
	if va.Kind() == reflect.Func {
		efaceA := *(*[2]unsafe.Pointer)(unsafe.Pointer(&a))
		efaceB := *(*[2]unsafe.Pointer)(unsafe.Pointer(&b))
		return efaceA[1] == efaceB[1]
	}
	return false
}
