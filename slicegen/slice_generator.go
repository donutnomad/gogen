package slicegen

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/donutnomad/gg"
	"github.com/donutnomad/gogen/plugin"
	"github.com/donutnomad/gogen/slicegen/generator"
)

const generatorName = "slicegen"

// SliceParams 定义 Slice 注解支持的参数
type SliceParams struct {
	Exclude string `param:"name=exclude,required=false,default=,description=排除的字段列表，格式: [a,b,c]"`
	Include string `param:"name=include,required=false,default=,description=包含的字段列表（优先于 exclude），格式: [a,b,c]"`
	Ptr     string `param:"name=ptr,required=false,default=true,description=是否生成指针类型: true|false"`
	Methods string `param:"name=methods,required=false,default=,description=生成的额外方法，格式: [filter,map,reduce,sort,groupby]"`
}

// SliceGenerator 实现 plugin.Generator 接口
type SliceGenerator struct {
	plugin.BaseGenerator
}

func NewSliceGenerator() *SliceGenerator {
	gen := &SliceGenerator{
		BaseGenerator: *plugin.NewBaseGeneratorWithParamsStruct(
			generatorName,
			[]string{"Slice"},
			[]plugin.TargetKind{plugin.TargetStruct},
			SliceParams{},
		),
	}
	gen.SetPriority(30) // Slice 优先级第三
	return gen
}

// Generate 执行代码生成
func (g *SliceGenerator) Generate(ctx *plugin.GenerateContext) (*plugin.GenerateResult, error) {
	result := plugin.NewGenerateResult()

	if len(ctx.Targets) == 0 {
		return result, nil
	}

	// 按输出文件分组处理
	// key: 输出路径, value: 待处理的目标列表
	fileTargets := make(map[string][]*sliceTargetInfo)

	for _, at := range ctx.Targets {
		ann := plugin.GetAnnotation(at.Annotations, "Slice")
		if ann == nil {
			continue
		}

		// 从 ParsedParams 获取解析好的参数
		var params SliceParams
		if at.ParsedParams != nil {
			var ok bool
			params, ok = at.ParsedParams.(SliceParams)
			if !ok {
				result.AddError(fmt.Errorf("ParsedParams 类型断言失败: %T", at.ParsedParams))
				continue
			}
		}

		// 解析参数
		excludeFields := parseArrayParam(params.Exclude)
		includeFields := parseArrayParam(params.Include)
		usePointer := parseBoolParam(params.Ptr, true) // 默认 true
		methods := parseArrayParamToSlice(params.Methods)

		// 计算输出路径
		fileConfig := ctx.GetFileConfig(at.Target.FilePath)
		outputPath := plugin.GetOutputPath(at.Target, ann, "$FILE_slice.go", fileConfig, g.Name(), ctx.DefaultOutput)

		fileTargets[outputPath] = append(fileTargets[outputPath], &sliceTargetInfo{
			filePath:      at.Target.FilePath,
			structName:    at.Target.Name,
			packageName:   at.Target.PackageName,
			excludeFields: excludeFields,
			includeFields: includeFields,
			usePointer:    usePointer,
			methods:       methods,
		})

		if ctx.Verbose {
			fmt.Printf("[slicegen] 处理结构体 %s -> %s\n", at.Target.Name, outputPath)
		}
	}

	// 为每个输出文件生成 gg 定义
	for outputPath, targets := range fileTargets {
		gen, err := g.generateDefinition(targets)
		if err != nil {
			result.AddError(fmt.Errorf("生成 %s 失败: %w", outputPath, err))
			continue
		}
		result.AddDefinition(outputPath, gen)
	}

	return result, nil
}

// sliceTargetInfo 存储单个目标的处理信息
type sliceTargetInfo struct {
	filePath      string
	structName    string
	packageName   string
	excludeFields map[string]bool
	includeFields map[string]bool
	usePointer    bool
	methods       []string
}

// generateDefinition 为一组目标生成 gg 定义
func (g *SliceGenerator) generateDefinition(targets []*sliceTargetInfo) (*gg.Generator, error) {
	if len(targets) == 0 {
		return nil, fmt.Errorf("没有目标需要生成")
	}

	// 收集所有结构体名称
	var structNames []string
	for _, t := range targets {
		structNames = append(structNames, t.structName)
	}

	// 使用第一个目标的信息
	firstTarget := targets[0]

	// 合并所有 exclude/include 字段配置
	excludeFields := make(map[string]bool)
	includeFields := make(map[string]bool)
	extraMethods := make(map[string]generator.IExecute)

	for _, t := range targets {
		for k, v := range t.excludeFields {
			excludeFields[k] = v
		}
		for k, v := range t.includeFields {
			includeFields[k] = v
		}

		// 处理额外方法
		for _, method := range t.methods {
			method = strings.ToLower(strings.TrimSpace(method))
			if impl := getMethodImpl(method); impl != nil {
				extraMethods[method] = impl
			}
		}
	}

	// 获取文件所在目录
	packageDir := filepath.Dir(firstTarget.filePath)

	// 创建原始 generator
	sliceGen := generator.NewGenerator(
		structNames,
		packageDir, // 使用文件所在目录
		excludeFields,
		includeFields,
		extraMethods,
		firstTarget.usePointer,
	)

	// 生成代码
	generatedCode, err := sliceGen.Generate()
	if err != nil {
		return nil, err
	}

	// 转换为 gg.Generator
	gen := gg.New()
	gen.SetPackage(firstTarget.packageName)
	gen.SetHeader("Code generated by %s. DO NOT EDIT.", generatorName)

	// 添加 imports
	for _, imp := range generatedCode.Imports {
		// 解析 import 语句
		imp = strings.TrimSpace(imp)
		if imp == "" {
			continue
		}
		// 移除引号
		imp = strings.Trim(imp, "\"")
		gen.P(imp)
	}

	// 添加代码体
	gen.Body().AddString(generatedCode.Body)

	return gen, nil
}

// getMethodImpl 根据方法名获取实现
func getMethodImpl(methodName string) generator.IExecute {
	allMethods := map[string]*generator.MyGenerator[generator.MethodTemplateData]{
		"filter":  &generator.MethodFilter,
		"map":     &generator.MethodMap,
		"reduce":  &generator.MethodReduce,
		"sort":    &generator.MethodSort,
		"groupby": &generator.MethodGroupBy,
	}

	if impl, ok := allMethods[methodName]; ok {
		return impl
	}
	return nil
}

// parseArrayParam 解析数组格式的参数 [a,b,c] -> map[string]bool
func parseArrayParam(s string) map[string]bool {
	result := make(map[string]bool)
	s = strings.TrimSpace(s)
	if s == "" {
		return result
	}

	// 移除方括号
	s = strings.TrimPrefix(s, "[")
	s = strings.TrimSuffix(s, "]")

	// 按逗号分割
	parts := strings.Split(s, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part != "" {
			result[part] = true
		}
	}

	return result
}

// parseArrayParamToSlice 解析数组格式的参数 [a,b,c] -> []string
func parseArrayParamToSlice(s string) []string {
	s = strings.TrimSpace(s)
	if s == "" {
		return nil
	}

	// 移除方括号
	s = strings.TrimPrefix(s, "[")
	s = strings.TrimSuffix(s, "]")

	// 按逗号分割
	parts := strings.Split(s, ",")
	var result []string
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part != "" {
			result = append(result, part)
		}
	}

	return result
}

// parseBoolParam 解析布尔参数，支持 true/false/1/0/t/f
func parseBoolParam(s string, defaultValue bool) bool {
	s = strings.ToLower(strings.TrimSpace(s))
	if s == "" {
		return defaultValue
	}
	switch s {
	case "true", "1", "t", "yes", "y":
		return true
	case "false", "0", "f", "no", "n":
		return false
	default:
		return defaultValue
	}
}
