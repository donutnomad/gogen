package gormgen

import (
	"fmt"

	"github.com/donutnomad/gg"
	"github.com/donutnomad/gogen/internal/gormparse"
	"github.com/donutnomad/gogen/internal/structparse"
	"github.com/donutnomad/gogen/plugin"
)

const generatorName = "gormgen"

// GsqlParams 定义 Gsql 注解支持的参数
type GsqlParams struct {
	Prefix string `param:"name=prefix,required=false,default=,description=生成的 Schema 结构体前缀"`
}

// GsqlGenerator 实现 plugin.Generator 接口
type GsqlGenerator struct {
	plugin.BaseGenerator
}

func NewGsqlGenerator() *GsqlGenerator {
	return &GsqlGenerator{
		BaseGenerator: *plugin.NewBaseGeneratorWithParamsStruct(
			generatorName,
			[]string{"Gsql"},
			[]plugin.TargetKind{plugin.TargetStruct},
			GsqlParams{}, // 传入参数结构体的零值实例
		),
	}
}

// Generate 执行代码生成
func (g *GsqlGenerator) Generate(ctx *plugin.GenerateContext) (*plugin.GenerateResult, error) {
	result := plugin.NewGenerateResult()

	if len(ctx.Targets) == 0 {
		return result, nil
	}

	// 按输出文件分组处理
	// key: 输出路径, value: 待处理的目标列表
	fileTargets := make(map[string][]*targetInfo)

	for _, at := range ctx.Targets {
		ann := plugin.GetAnnotation(at.Annotations, "Gsql")
		if ann == nil {
			continue
		}

		// 从 ParsedParams 获取解析好的参数
		var params GsqlParams
		if at.ParsedParams != nil {
			var ok bool
			params, ok = at.ParsedParams.(GsqlParams)
			if !ok {
				result.AddError(fmt.Errorf("ParsedParams 类型断言失败: %T", at.ParsedParams))
				continue
			}
		}

		// 解析结构体
		structInfo, err := structparse.ParseStruct(at.Target.FilePath, at.Target.Name)
		if err != nil {
			result.AddError(fmt.Errorf("解析结构体 %s 失败: %w", at.Target.Name, err))
			continue
		}

		// 转换为 GORM 模型（内部会推导表名）
		gormModel, err := gormparse.ParseGormModel(structInfo)
		if err != nil {
			result.AddError(fmt.Errorf("解析 GORM 模型失败: %w", err))
			continue
		}
		gormModel.Prefix = params.Prefix

		// 计算输出路径
		// 优先使用注解指定的 output，否则使用包级默认文件 generate.go
		fileConfig := ctx.GetFileConfig(at.Target.FilePath)
		outputPath := plugin.GetOutputPath(at.Target, ann, "$FILE_query.go", fileConfig, g.Name(), ctx.DefaultOutput)

		fileTargets[outputPath] = append(fileTargets[outputPath], &targetInfo{
			model:  gormModel,
			params: &params,
		})

		if ctx.Verbose {
			fmt.Printf("[gormgen] 处理结构体 %s -> %s\n", at.Target.Name, outputPath)
		}
	}

	// 为每个输出文件生成 gg 定义
	for outputPath, targets := range fileTargets {
		gen, err := g.generateDefinition(targets)
		if err != nil {
			result.AddError(fmt.Errorf("生成 %s 失败: %w", outputPath, err))
			continue
		}
		result.AddDefinition(outputPath, gen)
	}

	return result, nil
}

// targetInfo 存储单个目标的处理信息
type targetInfo struct {
	model  *gormparse.GormModelInfo
	params *GsqlParams
}

// generateDefinition 为一组目标生成 gg 定义
func (g *GsqlGenerator) generateDefinition(targets []*targetInfo) (*gg.Generator, error) {
	if len(targets) == 0 {
		return nil, fmt.Errorf("没有目标需要生成")
	}

	gen := gg.New()
	gen.SetPackage(targets[0].model.PackageName)
	gen.SetHeader("Code generated by %s. DO NOT EDIT.", generatorName)

	// 获取所需的包引用
	gsql := gen.P("github.com/donutnomad/gsql")
	field := gen.P("github.com/donutnomad/gsql/field")

	// 收集所有 imports
	for _, t := range targets {
		for _, imp := range getGormQueryImports(t.model) {
			gen.P(imp)
		}
	}

	// 生成 Query 代码
	for i, t := range targets {
		if i > 0 {
			gen.Body().AddLine()
		}
		generateModelCode(gen, t.model, gsql, field)
	}

	return gen, nil
}
